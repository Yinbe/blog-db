1. 引用计数法（Java没有采用）
每个对象有一个引用计数属性，新增一个引用时计数加1，引用释放时计数减1，计数为0时可以回
收。此方法简单，但无法解决对象相互循环引用的问题。

2.标记­清除算法（Mark­Sweep）
这是最基础的收集算法，如它的名字一样，算法分为“标记”和“清除”两个阶段：
首先标记出所有需要回收的对象，在标记完成后统一回收掉所有被标记的对象。

标记和清除过程的效率都不高；另外一个问题，标记清除之后会产生大量不连续的内存碎片，空间碎片太多可能会导致，当程
序在以后的运行过程中需要分配较大对象时无法找到足够的连续内存而不得不提前触发另一次垃圾收集动作。

3.复制算法（Copying）(新生代)
为了解决效率问题，一种称为“复制”（Copying）的收集算法出现了，它将可用内存按容
量划分为大小相等的两块，每次只使用其中的一块。当这一块的内存用完了，就将还存
活着的对象复制到另外一块上面，然后再把已使用过的内存空间一次清理掉。

空间浪费，需要整合标记。所以大对象一般不放在复制空间，直接进入老年代。

4.标记­整理算法(老年代)

标记过程仍然与“标记­清除”算法一样，但后续步骤不是直接对可回收对象进行清理，而是让所有存活的对象都向一端移动，然后直接清理掉端边界以外的内存 。这种方法避免了碎片的产生，同时也不需要一块额外的内存空间，对于老年代会比较合适。
但是相比复制算法，虽然该算法占用的内存空间少，但是耗费的垃圾回收时间会比复制算法久，所以上面也说了我们应该尽量避免或者减少 Full GC 的发生。

新生代发生的垃圾回收称为 Minor GC；老年代发生的 GC 称为 Full GC。

新生代使用复制算法进行垃圾回收；老年代使用标记­整理算法

PermGen（永久代）

绝大部分 Java 程序员应该都见过 "java.lang.OutOfMemoryError: PermGen space "这个异常。这里的 “PermGen space”其实指的就是方法区。不过方法区和“PermGen space”又有着本质的区别。前者是 JVM 的规范，而后者则是 JVM 规范的一种实现，并且只有 HotSpot 才有 “PermGen space”，而对于其他类型的虚拟机，如 JRockit（Oracle）、J9（IBM） 并没有“PermGen space”。由于方法区主要存储类的相关信息，所以对于动态生成类的情况比较容易出现永久代的内存溢出。

在 JDK 1.8 中， HotSpot 已经没有 “PermGen space”这个区间了，取而代之是一个叫做 Metaspace（元空间）元空间的本质和永久代类似，都是对JVM规范中方法区的实现。不过元空间与永久代之间最大的区别在于：元空间并不在虚拟机中，而是使用本地内存。因此，默认情况下，元空间的大小仅受本地内存限制，但可以通过参数来指定元空间的大小。
